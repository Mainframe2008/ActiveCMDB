.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::FormBuilder::Multi 3"
.TH CGI::FormBuilder::Multi 3 "2011-09-16" "perl v5.16.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::FormBuilder::Multi \- Create multi\-page FormBuilder forms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use CGI::FormBuilder::Multi;
\&    use CGI::Session;   # or something similar
\&
\&    # Top\-level "meta\-form"
\&    my $multi = CGI::FormBuilder::Multi\->new(
\&
\&        # form 1 options
\&        { fields   => [qw(name email daytime_phone evening_phone)],
\&          title    => \*(AqBasic Info\*(Aq,
\&          template => \*(Aqpage1.tmpl\*(Aq,
\&          validate => { name => \*(AqNAME\*(Aq, email => \*(AqEMAIL\*(Aq },
\&          required => [qw(name email daytime_phone)],
\&        },
\&
\&        # form 2 options
\&        { fields   => [qw(billing_name billing_card billing_exp
\&                          billing_address billing_city billing_state
\&                          billing_zip billing_phone)],
\&          title    => \*(AqBilling\*(Aq,
\&          template => \*(Aqpage2.tmpl\*(Aq,
\&          required => \*(AqALL\*(Aq,
\&        },
\&
\&        # form 3 options
\&        { fields   => [qw(same_as_billing shipping_address
\&                          shipping_city shipping_state shipping_zip)],
\&          title    => \*(AqShipping\*(Aq,
\&          template => \*(Aqpage3.tmpl\*(Aq,
\&          required => \*(AqALL\*(Aq,
\&        },
\&
\&        # a couple options specific to this module
\&        navbar => 1,
\&
\&        # remaining options (not in hashrefs) apply to all forms
\&        header => 1,
\&        method => \*(AqPOST\*(Aq,
\&        submit => \*(AqContinue\*(Aq,
\&        values => $dbi_hashref_query,
\&    );
\&
\&    # Get current page\*(Aqs form
\&    my $form = $multi\->form;
\&
\&    if ($form\->submitted && $form\->validate) {
\&
\&        # Retrieve session id
\&        my $sid = $form\->sessionid;
\&
\&        # Initialize session
\&        my $session = CGI::Session\->new("driver:File", $sid, {Directory=>\*(Aq/tmp\*(Aq});
\&
\&        # Automatically store updated data in session
\&        $session\->save_param($form);
\&
\&        # last page?
\&        if ($multi\->page == $multi\->pages) {
\&            print $form\->confirm;
\&            exit;
\&        }
\&
\&        # Still here, goto next page
\&        $multi\->page++;
\&
\&        # And re\-get form (no "my" on $form!)
\&        $form = $multi\->form;
\&
\&        # Make sure it has the right sessionid
\&        $form\->sessionid($session\->id);
\&
\&        # on page 3 we have special field handling
\&        if ($multi\->page == 3) {
\&            $form\->field(name    => \*(Aqsame_as_billing\*(Aq,
\&                         type    => \*(Aqcheckbox\*(Aq,
\&                         options => \*(AqYes\*(Aq,
\&                         jsclick => \*(Aqthis.form.submit()\*(Aq);
\&        }
\&    }
\&
\&    # Fall through and print next page\*(Aqs form
\&    print $form\->render;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module works with \f(CW\*(C`CGI::FormBuilder\*(C'\fR to create multi-page forms.
Each form is specified using the same options you would pass directly
into \fBFormBuilder\fR. See CGI::FormBuilder for a list of these options.
.PP
The multi-page \*(L"meta-form\*(R" is a composite of the individual forms you
specify, tied together via the special \f(CW\*(C`_page\*(C'\fR \s-1CGI\s0 param. The current
form is available via the \f(CW\*(C`form()\*(C'\fR method, and the current page is
available via \f(CW\*(C`page()\*(C'\fR. It's up to you to navigate appropriately:
.PP
.Vb 1
\&    my $multi = CGI::FormBuilder::Multi\->new(...);
\&
\&    # current form
\&    my $form  = $multi\->form;
\&
\&    $multi\->page++;         # page forward
\&    $multi\->page\-\-;         # and back
\&    $multi\->page = $multi\->pages;   # goto last page
\&
\&    # current form
\&    $form = $multi\->form;
.Ve
.PP
To make things are fluid as possible, you should title each of your
forms, even if you're using a template. This will allow \f(CW\*(C`::Multi\*(C'\fR
to create cross-links by-name instead of just \*(L"Page 2\*(R".
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.SS "new(\e%form1, \e%form2, opt => val)"
.IX Subsection "new(%form1, %form2, opt => val)"
This creates a new \f(CW\*(C`CGI::FormBuilder::Multi\*(C'\fR object. Forms are
specified as hashrefs of options, in sequential order, similar to
how fields are specified. The order the forms are in is the order
that the pages will cycle through.
.PP
In addition to a hashref, forms can be directly specified as a
\&\f(CW$form\fR object that has already been created. For existing objects,
the below does not apply.
.PP
When the first non-ref argument is seen, then all remaining args
are taken as common options that apply to all forms. In this way,
you can specify global settings for things like \f(CW\*(C`method\*(C'\fR or
\&\f(CW\*(C`header\*(C'\fR (which will likely be the same), and then override
individual settings like \f(CW\*(C`fields\*(C'\fR and \f(CW\*(C`validate\*(C'\fR on a per-form
basis.
.PP
If you do not wish to specify any options for your forms, you
can instead just specify the \f(CW\*(C`pages\*(C'\fR option, for example:
.PP
.Vb 1
\&    my $multi = CGI::FormBuilder::Multi\->new(pages => 3);
.Ve
.PP
With this approach, you will have to dynamically assemble each
page as you come to them. The mailing list can help.
.PP
The \*(L"\s-1SYNOPSIS\s0\*(R" above is very representative of typical usage.
.SS "\fIform()\fP"
.IX Subsection "form()"
This returns the current page's form, as an object created
directly by \f(CW\*(C`CGI::FormBuilder\->new\*(C'\fR. All valid \fBFormBuilder\fR
methods and options work on the form. To change which form is
returned, us \f(CW\*(C`page()\*(C'\fR.
.SS "page($num)"
.IX Subsection "page($num)"
This sets and returns the current page. It can accept a page number
either as an argument, or directly as an assignment:
.PP
.Vb 2
\&    $multi\->page(1);    # page 1
\&    $multi\->page = 1;   # same thing
\&
\&    $multi\->page++;     # next page
\&    $multi\->page\-\-;     # back one
\&
\&    if ($multi\->page == $multi\->pages) {
\&        # last page
\&    }
.Ve
.PP
Hint: Usually, you should only change pages once you have validated
the current page's form appropriately.
.SS "\fIpages()\fP"
.IX Subsection "pages()"
This returns the total number of pages. Actually, what it returns
is an array of all forms (and hence it has the alias \f(CW\*(C`forms()\*(C'\fR),
which just so happens to become the length in a scalar context,
just like anywhere else in Perl.
.SS "navbar($onoff)"
.IX Subsection "navbar($onoff)"
This returns a navigation bar that allows the user to jump between
pages of the form. This is useful if you want to let a person fill
out different pages out of order. In most cases, you do \fInot\fR
want this, so it's off by default.
.PP
To use it, the best way is setting \f(CW\*(C`navbar => 1\*(C'\fR in \f(CW\*(C`new()\*(C'\fR.
However, you can also get it yourself to render your own \s-1HTML:\s0
.PP
.Vb 2
\&    my $html = $multi\->navbar;      # scalar HTML
\&    my @link = $multi\->navbar;      # array of links
.Ve
.PP
This is useful in something like this:
.PP
.Vb 3
\&    my $nav = $multi\->navbar;
\&    $form = $multi\->form;
\&    $form\->tmpl_param(navbar => $navbar);
.Ve
.PP
The navbar will have two style classes: \f(CW\*(C`fb_multi_page\*(C'\fR for the
current page's link, and \f(CW\*(C`fb_multi_link\*(C'\fR for the others.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CGI::FormBuilder
.SH "REVISION"
.IX Header "REVISION"
\&\f(CW$Id:\fR Multi.pm 100 2007\-03\-02 18:13:13Z nwiger $
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) Nate Wiger <http://nateware.com>. All Rights Reserved.
.PP
This module is free software; you may copy this under the terms of
the \s-1GNU\s0 General Public License, or the Artistic License, copies of
which should have accompanied your Perl kit.
