.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::FormBuilder::Template::HTML 3"
.TH CGI::FormBuilder::Template::HTML 3 "2011-09-16" "perl v5.16.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::FormBuilder::Template::HTML \- FormBuilder interface to HTML::Template
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    my $form = CGI::FormBuilder\->new(
\&                    fields   => \e@fields,
\&                    template => \*(Aqform.tmpl\*(Aq,
\&               );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This engine adapts \fBFormBuilder\fR to use \f(CW\*(C`HTML::Template\*(C'\fR.
\&\f(CW\*(C`HTML::Template\*(C'\fR is the default template option and is activated
one of two ways. Either:
.PP
.Vb 4
\&    my $form = CGI::FormBuilder\->new(
\&                    fields => \e@fields,
\&                    template => \*(Aqform.tmpl\*(Aq,
\&               );
.Ve
.PP
Or, you can specify any options which \f(CW\*(C`HTML::Template\->new\*(C'\fR
accepts by using a hashref:
.PP
.Vb 9
\&    my $form = CGI::FormBuilder\->new(
\&                    fields => \e@fields,
\&                    template => {
\&                        type => \*(AqHTML\*(Aq,
\&                        filename => \*(Aqform.tmpl\*(Aq,
\&                        shared_cache => 1,
\&                        loop_context_vars => 1
\&                    }
\&                );
.Ve
.PP
The following methods are provided (usually only used internally):
.SS "engine"
.IX Subsection "engine"
Returns a reference to the \f(CW\*(C`HTML::Template\*(C'\fR object
.SS "prepare"
.IX Subsection "prepare"
Returns a hash of all the fields ready to be rendered.
.SS "render"
.IX Subsection "render"
Uses the prepared hash and expands the template, returning a string of \s-1HTML\s0.
.SH "TEMPLATES"
.IX Header "TEMPLATES"
In your template, each of the form fields will correspond directly to
a \f(CW\*(C`<tmpl_var>\*(C'\fR of the same name prefixed with \*(L"field\-\*(R" in the
template. So, if you defined a field called \*(L"email\*(R", then you would
setup a variable called \f(CW\*(C`<tmpl_var field\-email>\*(C'\fR in your template.
.PP
In addition, there are a couple special fields:
.PP
.Vb 6
\&    <tmpl_var js\-head>     \-  JavaScript to stick in <head>
\&    <tmpl_var form\-title>  \-  The <title> of the HTML form
\&    <tmpl_var form\-start>  \-  Opening <form> tag and internal fields
\&    <tmpl_var form\-submit> \-  The submit button(s)
\&    <tmpl_var form\-reset>  \-  The reset button
\&    <tmpl_var form\-end>    \-  Just the closing </form> tag
.Ve
.PP
Let's look at an example \f(CW\*(C`form.tmpl\*(C'\fR template we could use:
.PP
.Vb 10
\&    <html>
\&    <head>
\&    <title>User Information</title>
\&    <tmpl_var js\-head><!\-\- this holds the JavaScript code \-\->
\&    </head>
\&    <tmpl_var form\-start><!\-\- this holds the initial form tag \-\->
\&    <h3>User Information</h3>
\&    Please fill out the following information:
\&    <!\-\- each of these tmpl_var\*(Aqs corresponds to a field \-\->
\&    <p>Your full name: <tmpl_var field\-name>
\&    <p>Your email address: <tmpl_var field\-email>
\&    <p>Choose a password: <tmpl_var field\-password>
\&    <p>Please confirm it: <tmpl_var field\-confirm_password>
\&    <p>Your home zipcode: <tmpl_var field\-zipcode>
\&    <p>
\&    <tmpl_var form\-submit><!\-\- this holds the form submit button \-\->
\&    </form><!\-\- can also use "tmpl_var form\-end", same thing \-\->
.Ve
.PP
As you see, you get a \f(CW\*(C`<tmpl_var>\*(C'\fR for each for field you define.
.PP
However, you may want even more control. That is, maybe you want
to specify every nitty-gritty detail of your input fields, and
just want this module to take care of the statefulness of the
values. This is no problem, since this module also provides
several other \f(CW\*(C`<tmpl_var>\*(C'\fR tags as well:
.PP
.Vb 5
\&    <tmpl_var value\-[field]>   \- The value of a given field
\&    <tmpl_var label\-[field]>   \- The human\-readable label
\&    <tmpl_var comment\-[field]> \- Any optional comment
\&    <tmpl_var error\-[field]>   \- Error text if validation fails
\&    <tmpl_var required\-[field]> \- See if the field is required
.Ve
.PP
This means you could say something like this in your template:
.PP
.Vb 3
\&    <tmpl_var label\-email>:
\&    <input type="text" name="email" value="<tmpl_var value\-email>">
\&    <font size="\-1"><i><tmpl_var error\-email></i></font>
.Ve
.PP
And \fBFormBuilder\fR would take care of the value stickiness for you,
while you have control over the specifics of the \f(CW\*(C`<input>\*(C'\fR tag.
A sample expansion may create \s-1HTML\s0 like the following:
.PP
.Vb 3
\&    Email:
\&    <input type="text" name="email" value="nate@wiger.org">
\&    <font size="\-1"><i>You must enter a valid value</i></font>
.Ve
.PP
Note, though, that this will only get the \fIfirst\fR value in the case
of a multi-value parameter (for example, a multi-select list). To
remedy this, if there are multiple values you will also get a
\&\f(CW\*(C`<tmpl_var>\*(C'\fR prefixed with \*(L"loop\-\*(R". So, if you had:
.PP
.Vb 1
\&    myapp.cgi?color=gray&color=red&color=blue
.Ve
.PP
This would give the \f(CW\*(C`color\*(C'\fR field three values. To create a select
list, you would do this in your template:
.PP
.Vb 5
\&    <select name="color" multiple>
\&    <tmpl_loop loop\-color>
\&        <option value="<tmpl_var value>"><tmpl_var label></option>
\&    </tmpl_loop>
\&    </select>
.Ve
.PP
With \f(CW\*(C`<tmpl_loop>\*(C'\fR tags, each iteration gives you several
variables:
.PP
.Vb 6
\&    Inside <tmpl_loop>, this...  Gives you this
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    <tmpl_var value>             value of that option
\&    <tmpl_var label>             label for that option
\&    <tmpl_var checked>           if selected, the word "checked"
\&    <tmpl_var selected>          if selected, the word "selected"
.Ve
.PP
Please note that \f(CW\*(C`<tmpl_var value>\*(C'\fR gives you one of the \fIoptions\fR,
not the values. Why? Well, if you think about it you'll realize that
select lists and radio groups are fundamentally different from input
boxes in a number of ways. Whereas in input tags you can just have
an empty value, with lists you need to iterate through each option
and then decide if it's selected or not.
.PP
When you need precise control in a template this is all exposed to you;
normally \fBFormBuilder\fR does all this magic for you. If you don't need
exact control over your lists, simply use the \f(CW\*(C`<tmpl_var field\-[name]>\*(C'\fR
tag and this will all be done automatically, which I strongly recommend.
.PP
But, let's assume you need exact control over your lists. Here's an
example select list template:
.PP
.Vb 5
\&    <select name="color" multiple>
\&    <tmpl_loop loop\-color>
\&    <option value="<tmpl_var value>" <tmpl_var selected>><tmpl_var label>
\&    </tmpl_loop>
\&    </select>
.Ve
.PP
Then, your Perl code would fiddle the field as follows:
.PP
.Vb 4
\&    $form\->field( 
\&              name => \*(Aqcolor\*(Aq, nameopts => 1,
\&              options => [qw(red green blue yellow black white gray)]
\&           );
.Ve
.PP
Assuming query string as shown above, the template would then be expanded
to something like this:
.PP
.Vb 9
\&    <select name="color" multiple>
\&    <option value="red" selected>Red
\&    <option value="green" >Green
\&    <option value="blue" selected>Blue
\&    <option value="yellow" >Yellow
\&    <option value="black" >Black
\&    <option value="white" >White
\&    <option value="gray" selected>Gray
\&    </select>
.Ve
.PP
Notice that the \f(CW\*(C`<tmpl_var selected>\*(C'\fR tag is expanded to the word
\&\*(L"selected\*(R" when a given option is present as a value as well (i.e.,
via the \s-1CGI\s0 query). The \f(CW\*(C`<tmpl_var value>\*(C'\fR tag expands to each option
in turn, and \f(CW\*(C`<tmpl_var label>\*(C'\fR is expanded to the label for that
value. In this case, since \f(CW\*(C`nameopts\*(C'\fR was specified to \f(CW\*(C`field()\*(C'\fR, the
labels are automatically generated from the options.
.PP
Let's look at one last example. Here we want a radio group that allows
a person to remove themself from a mailing list. Here's our template:
.PP
.Vb 9
\&    Do you want to be on our mailing list?
\&    <p><table>
\&    <tmpl_loop loop\-mailopt>
\&    <td bgcolor="silver">
\&      <input type="radio" name="mailopt" value="<tmpl_var value>">
\&    </td>
\&    <td bgcolor="white"><tmpl_var label></td>
\&    </tmpl_loop>
\&    </table>
.Ve
.PP
Then, we would twiddle our \f(CW\*(C`mailopt\*(C'\fR field via \f(CW\*(C`field()\*(C'\fR:
.PP
.Vb 7
\&    $form\->field(
\&              name => \*(Aqmailopt\*(Aq,
\&              options => [
\&                 [ 1 => \*(AqYes, please keep me on it!\*(Aq ],
\&                 [ 0 => \*(AqNo, remove me immediately.\*(Aq ]
\&              ]
\&           );
.Ve
.PP
When the template is rendered, the result would be something like this:
.PP
.Vb 2
\&    Do you want to be on our mailing list?
\&    <p><table>
\&
\&    <td bgcolor="silver">
\&      <input type="radio" name="mailopt" value="1">
\&    </td>
\&    <td bgcolor="white">Yes, please keep me on it!</td>
\&
\&    <td bgcolor="silver">
\&      <input type="radio" name="mailopt" value="0">
\&    </td>
\&    <td bgcolor="white">No, remove me immediately</td>
\&
\&    </table>
.Ve
.PP
When the form was then sumbmitted, you would access the values just
like any other field:
.PP
.Vb 5
\&    if ($form\->field(\*(Aqmailopt\*(Aq)) {
\&        # is 1, so add them
\&    } else {
\&        # is 0, remove them
\&    }
.Ve
.PP
Finally, you can also loop through each of the fields using the top-level
\&\f(CW\*(C`fields\*(C'\fR loop in your template. This allows you to reuse the
same template even if your parameters change. The following template
code would loop through each field, creating a table row for each:
.PP
.Vb 8
\&    <table>
\&    <tmpl_loop fields>
\&    <tr>
\&    <td class="small"><tmpl_if required><b><tmpl_var label></b><tmpl_else><tmpl_var label></tmpl_if></td>
\&    <td><tmpl_var field></td>
\&    </tr>
\&    </tmpl_loop>
\&    </table>
.Ve
.PP
Each loop will have a \f(CW\*(C`label\*(C'\fR, \f(CW\*(C`field\*(C'\fR, \f(CW\*(C`value\*(C'\fR, etc, just like above.
.PP
For more information on templates, see HTML::Template.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CGI::FormBuilder, CGI::FormBuilder::Template, HTML::Template
.SH "REVISION"
.IX Header "REVISION"
\&\f(CW$Id:\fR \s-1HTML\s0.pm 100 2007\-03\-02 18:13:13Z nwiger $
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) Nate Wiger <http://nateware.com>. All Rights Reserved.
.PP
This module is free software; you may copy this under the terms of
the \s-1GNU\s0 General Public License, or the Artistic License, copies of
which should have accompanied your Perl kit.
